# 응용시스템 분산화

## 분산 처리 시스템의 목적

- 자원 공유: 네트워크를 통해 연결된 시스템들이 유용한 자원을 공유할 수 있습니다.
- 연산 속도 향상: 작업을 여러 시스템에 분산시켜 처리함으로써 전체적인 연산 속도가 향상됩니다.
- 신뢰도 향상: 한 시스템에 오류가 발생해도 다른 시스템들이 계속 작업을 수행할 수 있어 전체 시스템의 신뢰도가 높아집니다.
- 컴퓨터 통신: 지리적으로 떨어진 시스템들 간에도 정보 교환이 가능합니다.

## 분산 처리 시스템의 장점

- 사용자 간 통신 용이성
- 제한된 자원의 공유
- 중앙 컴퓨터 과부하 감소
- 시스템의 점진적 확장 가능성
- 연산 속도, 신뢰도, 사용 가능도 향상
- 결함 허용 가능

---

## 1. 데이터 샤딩

- 대규모 데이터베이스를 더 작고 관리하기 쉬운 단위로 분할하는 데이터 처리 기법.

### 장점

- 데이터 처리 속도 향상: 각 노드가 처리해야 할 데이터량이 줄어들어 전체적인 처리 속도가 빨라집니다.
- 탈중앙화 및 보안성 강화: 데이터가 여러 저장소에 분산되어 있어 중앙 집중식 저장 방식에 비해 해킹 위험이 낮아집니다.

### 단점

- 복잡성 증가: 데이터가 여러 곳에 분산되어 있어 조회 및 관리가 복잡해질 수 있습니다.
- 데이터 처리 지연: 샤드 간 통신이 빈번할 경우 오히려 처리 속도가 지연될 수 있습니다.

### 샤딩 전략

- 범위 기반 샤딩: 지정된 값의 범위를 기준으로 데이터를 분할합니다.
- 해시 기반 샤딩: 선택한 키(예: 고객 ID)에 해시 함수를 적용하여 데이터를 분산합니다.
- 목록 기반 샤딩: 사전 정의된 목록을 기반으로 특정 데이터를 저장할 샤드를 명시적으로 지정합니다.

## 2. MSA

### 주요 이점

- 향상된 확장성: 각 서비스를 독립적으로 확장할 수 있어 수요에 따라 효율적으로 리소스를 할당할 수 있습니다. 특정 기능에 대한 수요가 증가하면 해당 서비스만 확장하면 되므로 비용 효율성이 높아집니다.
- 유연성과 민첩성 개선: 서비스를 독립적으로 개발, 업데이트, 배포할 수 있어 빠른 개발 주기와 신속한 기능 출시가 가능합니다. 특정 서비스만 변경하면 되므로 전체 시스템에 영향을 주지 않고 빠르게 업데이트할 수 있습니다.
- 장애 격리: 각 서비스가 독립적으로 실행되므로 한 서비스의 장애가 전체 시스템으로 확산되지 않습니다. 이는 전반적인 시스템 안정성과 신뢰성을 향상시킵니다.

### 구현 시 고려사항

- 비즈니스 도메인 중심으로 서비스 정의
- HTTP/REST API 등 경량 통신 프로토콜 사용
- 서비스 디스커버리 메커니즘 구현
- 장애 시나리오에 대비한 재시도, 타임아웃, 서킷 브레이커 등 구현
- 자동화된 테스트 및 배포를 위한 DevOps 방식 도입

## 3. 이벤트 기반 아키텍쳐 (EDA)

- 시스템 내의 상태 변화나 중요한 비즈니스 순간을 '이벤트'로 감지하고 실시간으로 대응하는 소프트웨어 설계 패턴.

### 주요 구성 요소

- 이벤트 생산자(Event Producer): 이벤트를 생성하고 발행하는 주체.
- 이벤트 소비자(Event Consumer): 이벤트를 수신하고 처리하는 주체.
- 이벤트 브로커(Event Broker): 이벤트를 중개하고 라우팅하는 역할 (선택적).

### 작동 방식

- 이벤트 생산자가 상태 변화를 감지하고 이벤트를 생성합니다.
- 생성된 이벤트는 이벤트 브로커나 메시지 버스로 전송됩니다.
- 관심 있는 이벤트 소비자들이 비동기적으로 이벤트를 수신하고 처리합니다.

### 주요 이점

- 느슨한 결합(Loose Coupling): 서비스들이 이벤트를 통해 상호작용하므로, 각 컴포넌트를 독립적으로 개발, 배포, 확장할 수 있습니다.
- 확장성과 유연성: 시스템 컴포넌트들이 독립적으로 확장 가능하며, 새로운 기능을 쉽게 추가할 수 있습니다.
- 실시간 처리: 이벤트가 발생하면 즉시 처리할 수 있어 실시간 인사이트와 대응이 가능합니다.
- 장애 격리: 한 서비스의 장애가 전체 시스템으로 확산되지 않습니다.

## 4. HA/가용성

### Quorum

클러스터가 정상적으로 작동하기 위해 필요한 최소한의 노드 수 = 일반적으로 전체 노드 수의 과반수(50% 이상).

#### 쿼럼의 작동 방식

1. 투표 시스템: 클러스터의 각 노드에 투표권을 할당하고, 과반수의 투표가 있을 때만 클러스터 작업을 진행합니다.
2. 스플릿 브레인 방지: 네트워크 분할 상황에서 각 부분이 독립적으로 작동하여 데이터 불일치가 발생하는 것을 막습니다.
3. 자동 조치: 쿼럼이 깨지면(과반수 노드 실패 시) 클러스터 관리 소프트웨어(예: Pacemaker)가 자동으로 리소스를 중지시켜 데이터 보호합니다.

#### 고가용성 확보를 위한 쿼럼 활용

1. 노드 수 설정: 일반적으로 홀수 개의 노드(3, 5, 7 등)로 구성하여 쿼럼 달성을 용이하게 합니다.
2. 자동 페일오버: 쿼럼이 유지되는 한, 일부 노드 실패 시 자동으로 다른 노드로 서비스를 이전합니다.
3. 데이터 일관성: 쿼럼을 통해 모든 노드 간 데이터 동기화를 보장하여 일관성을 유지합니다.
4. 펜싱(Fencing): 문제가 있는 노드를 클러스터에서 격리하여 전체 시스템 안정성을 확보합니다.

## 5. 모놀리식 시스템과의 차이점

| 특성 | 모놀리식 시스템 | 분산화된 시스템 |
| ------------------ | -------------------------- | ------------------------------- |
| 아키텍처 | 단일 구조 | 여러 독립 서비스로 구성 |
| 코드베이스 | 단일 코드베이스 | 서비스별 독립적인 코드베이스 |
| 데이터베이스 | 하나의 공유 데이터베이스 | 서비스별 독립 데이터베이스 가능 |
| 배포 | 전체 시스템을 한 번에 배포 | 서비스별 독립적인 배포 가능 |
| 확장 방식 | 수직적 확장(Scale-up) | 수평적 확장(Scale-out) |
| 개발 및 배포 | 상대적으로 간단 | 서비스별 독립적 개발/배포 |
| 시스템 관리 | 전체 관리 용이 | 개별 서비스 관리 필요 |
| 초기 개발 속도 | 빠름 | 상대적으로 느림 |
| 확장성 | 제한적 | 높은 확장성과 유연성 |
| 장애 격리 | 어려움 | 용이함 |
| 기술 다양성 | 단일 기술 스택 | 서비스별 다양한 기술 사용 가능 |
| 복잡성 | 규모 증가에 따라 복잡해짐 | 초기부터 복잡하나 관리 용이 |
| 서비스 간 통신 | 내부 함수 호출 | API 통신 (오버헤드 발생) |
| 데이터 일관성 | 유지 용이 | 유지가 어려움 |
| 장애 영향 | 전체 시스템에 영향 | 일부 서비스에 국한 |

## 6. 트레이싱

여러 서비스와 시스템에 걸쳐 요청의 흐름을 추적하고 관찰하는 기술.

### 주요 구성 요소

1. 트랜잭션 (Transaction): 애플리케이션에서 수행되는 작업 단위.
2. 요청 (Request): 서비스 간 통신의 기본 단위.
3. 트레이스 (Trace): 전체 요청 경로에 대한 성능 데이터 집합.
4. 스팬 (Span): 트레이스의 개별 작업 또는 세그먼트.
5. 트레이스 컨텍스트 (Trace Context): 서비스 간 전달되는 상관 관계 식별자.

### 작동 원리

1. 요청이 시스템에 들어오면 고유 ID가 할당됩니다.
2. 요청이 각 서비스를 통과할 때마다 스팬이 생성됩니다.
3. 스팬들은 트레이스 컨텍스트를 통해 연결됩니다.
4. 모든 스팬이 모여 전체 트레이스를 형성합니다.

### 주요 기능

1. 요청 경로 추적 (Request Path Tracking)
2. 서비스 종속성 파악 (Service Dependency Identification)
3. 레이턴시 측정 (Latency Measurement)
4. 병목 현상 식별 (Bottleneck Identification)
5. 오류 위치 확인 및 분석 (Error Location Identification and Analysis)

### 샘플링 기법

테일 기반 샘플링 (Tail-based Sampling): 완료된 트레이스에 대해 모든 정보를 수집하며, 특히 오류나 비정상적인 레이턴시가 있는 트레이스를 중점적으로 샘플링합니다.

## 7. 트랜잭션

### 데이터 동기화 전략

1. 최종 일관성(Eventual Consistency) 전략:
   - 백그라운드 동기화 패턴:
     - 주기적으로 데이터 소스를 체크하여 동기화
     - 장점: 서비스 간 디커플링, 응답성 좋음
     - 단점: 동기화에 시간 소요, 데이터 소스 결합 발생
   - 이벤트 기반 패턴:
     - 비동기 메시지 처리로 데이터 동기화
     - 장점: 빠른 응답성, 서비스 간 디커플링, 적시 데이터 동기화
     - 단점: 복잡한 에러 처리 필요
   
2. 강한 일관성 전략:
   - 2단계 커밋(2PC) 프로토콜:
     - 준비와 커밋 단계로 트랜잭션 처리
     - 장점: 데이터 일관성 보장
     - 단점: 성능 저하, 단일 실패점 존재
   - 3단계 커밋 (3PC) 프로토콜:
     - 2PC에 '준비 완료' 단계 추가
     - 노드 장애 시에도 안전한 트랜잭션 처리 가능
     - 2PC보다 복잡하지만 더 안정적
   
3. 보상 트랜잭션 전략:
   - TC/C(Try-Confirm/Cancel) 패턴:
     - 자원 예약 후 확정/취소 단계로 처리
     - 장점: REST 기반 시스템에 적합
     - 단점: 구현 복잡도 증가
   - Saga 패턴:
     - 일련의 로컬 트랜잭션으로 구성, 보상 트랜잭션 정의
     - 장점: 장기 실행 트랜잭션에 적합
     - 단점: 복잡한 오류 처리 로직 필요
   
4. 기타 전략:
   - 분산 락 관리
   - 여러 노드 간 리소스 접근 동기화
   - 데드락 방지 메커니즘 필요
   - 타임스탬프 기반 트랜잭션 관리
   - 각 트랜잭션에 타임스탬프 부여하여 충돌 해결 및 일관성 유지에 활용
   
## 8. 오류 처리 매커니즘

### 재시도 메커니즘

자동 재시도와 백오프 전략을 통해 네트워크 문제와 같은 일시적인 오류를 처리합니다.

### 서킷 브레이커 패턴

이 패턴은 이벤트 핸들러의 상태를 모니터링하고 실패하는 핸들러로의 이벤트 전송을 중단하여 연쇄 실패를 방지합니다.

세 가지 상태:

1. Closed (닫힘): 정상 작동 상태로 요청이 서비스로 전달됩니다.
2. Open (열림): 장애 감지 상태에서 모든 요청을 즉시 거부합니다.
3. Half-Open (반열림): 복구 시도 상태에서 제한된 수의 요청만 허용하여 서비스 상태를 확인합니다.

### 오류 처리기 프로세서

오류 처리를 전담하는 별도의 컴포넌트입니다.

1. 이벤트 소비자가 오류를 만나면 해당 이벤트를 오류 처리기로 보냅니다.
2. 오류 처리기는 문제 해결을 시도하고 이벤트를 원래 채널로 재전송합니다.
3. 실패 시 수동 검사를 위해 관리자에게 이벤트를 전달할 수 있습니다.

## 9. 이벤트 로깅 및 모니터링 

상세한 오류 로깅은 진단과 문제 해결에 도움을 줍니다. 모니터링 시스템은 반복되는 문제를 관리자에게 알릴 수 있습니다.

### 데드 레터 큐 

반복적으로 처리에 실패한 이벤트는 나중에 분석하고 수동 개입이 가능하도록 "데드 레터 큐"로 이동됩니다.

### 데이터 지속성 

데이터 손실을 방지하기 위해 전송 중인 이벤트는 다음 컴포넌트가 수신을 확인할 때까지 유지됩니다.

### 오류 격리 

오류가 전체 시스템에 영향을 미치지 않도록 격리됩니다.

### 비동기 오류 처리 

주요 이벤트 처리 흐름을 차단하지 않기 위해 오류는 종종 비동기적으로 처리됩니다.

## 10. CQRS 

데이터 저장소의 읽기 및 쓰기 작업을 분리하는 아키텍처 패턴입니다.

### 핵심 개념 

명령 (Commands): 데이터 변경(생성, 업데이트, 삭제) 처리  
조회 (Queries): 데이터 검색(읽기) 처리  

### 주요 이점 

읽기와 쓰기 작업을 별도로 최적화하여 성능 향상  
읽기 및 쓰기 모델을 독립적으로 확장할 수 있어 확장성 개선  
시간이 지남에 따라 시스템을 발전시키는 데 있어 유연성이 증가  
도메인 모델의 복잡성이 감소  

### 아키텍처 

명령 측 (Command side): 쓰기 작업 처리  
조회 측 (Query side): 읽기 작업 처리  

### 일반적인 구현 

읽기와 쓰기 작업에 대해 서로 다른 데이터베이스 사용  
CQRS와 함께 이벤트 소싱 구현  
명령과 조회 모델 간 변경 사항을 전파하기 위한 메시징 시스템 사용

